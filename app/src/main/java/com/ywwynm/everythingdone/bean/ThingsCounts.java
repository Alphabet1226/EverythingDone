package com.ywwynm.everythingdone.bean;

import android.content.Context;
import android.content.SharedPreferences;

import com.ywwynm.everythingdone.Definitions;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.text.NumberFormat;

/**
 * Created by ywwynm on 2015/7/11.
 * Model layer for database generated by table things_count
 */
public class ThingsCounts {

    public static final String TAG = "ThingsCounts";

    public static final int ALL = Thing.DELETED + 1;

    private Context mContext;

    private static ThingsCounts sThingsCounts;

    private int[][] mCounts;
    private int mHabitFinished;
    private int mHabitRecord;

    private Runnable mWriteFileRunnable;

    private ThingsCounts(Context context) {
        mContext = context;
        SharedPreferences metaData = context.getSharedPreferences(
                Definitions.MetaData.META_DATA_NAME, Context.MODE_PRIVATE);
        if (metaData.getBoolean(Definitions.MetaData.KEY_FIRST_TIME_USED, true)) {
            init();
            metaData.edit().putBoolean(Definitions.MetaData.KEY_FIRST_TIME_USED, false).apply();
        } else {
            readFromFile();
        }
        mWriteFileRunnable = new Runnable() {
            @Override
            public void run() {
                writeToFile();
            }
        };
    }

    public static ThingsCounts getInstance(Context context) {
        if (sThingsCounts == null) {
            synchronized (ThingsCounts.class) {
                if (sThingsCounts == null) {
                    sThingsCounts = new ThingsCounts(context);
                }
            }
        }
        return sThingsCounts;
    }

    public int getThingsCountForActivityHeader(int limit) {
        int count = 0;
        switch (limit) {
            case Definitions.LimitForGettingThings.ALL_UNDERWAY:
                for (int i = Thing.NOTE; i <= Thing.WELCOME_UNDERWAY; i++) {
                    count += mCounts[i][Thing.UNDERWAY];
                }
                count += mCounts[Thing.NOTIFICATION_UNDERWAY][Thing.UNDERWAY];
                break;
            case Definitions.LimitForGettingThings.NOTE_UNDERWAY:
                count = mCounts[Thing.NOTE][Thing.UNDERWAY]
                        + mCounts[Thing.WELCOME_NOTE][Thing.UNDERWAY]
                        + mCounts[Thing.NOTIFICATION_NOTE][Thing.UNDERWAY];
                break;
            case Definitions.LimitForGettingThings.REMINDER_UNDERWAY:
                count = mCounts[Thing.REMINDER][Thing.UNDERWAY]
                        + mCounts[Thing.WELCOME_REMINDER][Thing.UNDERWAY]
                        + mCounts[Thing.NOTIFICATION_REMINDER][Thing.UNDERWAY];
                break;
            case Definitions.LimitForGettingThings.HABIT_UNDERWAY:
                count = mCounts[Thing.HABIT][Thing.UNDERWAY]
                        + mCounts[Thing.WELCOME_HABIT][Thing.UNDERWAY]
                        + mCounts[Thing.NOTIFICATION_HABIT][Thing.UNDERWAY];
                break;
            case Definitions.LimitForGettingThings.GOAL_UNDERWAY:
                count = mCounts[Thing.GOAL][Thing.UNDERWAY]
                        + mCounts[Thing.WELCOME_GOAL][Thing.UNDERWAY]
                        + mCounts[Thing.NOTIFICATION_GOAL][Thing.UNDERWAY];
                break;
            case Definitions.LimitForGettingThings.ALL_FINISHED:
                for (int i = Thing.NOTE; i <= Thing.NOTIFICATION_GOAL; i++) {
                    count += mCounts[i][Thing.FINISHED];
                }
                break;
            case Definitions.LimitForGettingThings.ALL_DELETED:
                for (int i = Thing.NOTE; i <= Thing.NOTIFICATION_GOAL; i++) {
                    count += mCounts[i][Thing.DELETED];
                }
                break;
        }
        return count;
    }

    public String getCompletionRate(int limit) {
        int[] counts = new int[2];
        switch (limit) {
            case Definitions.LimitForGettingThings.ALL_UNDERWAY:
            case Definitions.LimitForGettingThings.ALL_FINISHED:
            case Definitions.LimitForGettingThings.ALL_DELETED:
                for (int i = Thing.NOTE; i <= Thing.GOAL; i++) {
                    counts[0] += mCounts[i][Thing.FINISHED];
                    counts[1] += mCounts[i][ALL];
                }
                counts[0] -= mCounts[Thing.HABIT][Thing.FINISHED];
                counts[1] -= mCounts[Thing.HABIT][ALL];
                counts[0] += mHabitFinished;
                counts[1] += mHabitRecord;
                break;
            case Definitions.LimitForGettingThings.NOTE_UNDERWAY:
                counts[0] = mCounts[Thing.NOTE][Thing.FINISHED];
                counts[1] = mCounts[Thing.NOTE][ALL];
                break;
            case Definitions.LimitForGettingThings.REMINDER_UNDERWAY:
                counts[0] = mCounts[Thing.REMINDER][Thing.FINISHED];
                counts[1] = mCounts[Thing.REMINDER][ALL];
                break;
            case Definitions.LimitForGettingThings.HABIT_UNDERWAY:
                counts[0] = mHabitFinished;
                counts[1] = mHabitRecord;
                break;
            case Definitions.LimitForGettingThings.GOAL_UNDERWAY:
                counts[0] = mCounts[Thing.GOAL][Thing.FINISHED];
                counts[1] = mCounts[Thing.GOAL][ALL];
                break;
        }
        if (counts[1] == 0) {
            return "0 %";
        } else {
            NumberFormat nf = NumberFormat.getPercentInstance();
            nf.setMaximumFractionDigits(2);
            String str = nf.format((float) counts[0] / counts[1]);
            return str.substring(0, str.length() - 1) + " %";
        }
    }

    public void handleCreation(int type) {
        mCounts[type][Thing.UNDERWAY]++;
        mCounts[type][3]++;
    }

    public void handleUpdate(int typeBefore, int stateBefore, int typeAfter, int stateAfter) {
        if (stateBefore != Thing.DELETED_FOREVER) {
            mCounts[typeBefore][stateBefore]--;
        }
        if (stateAfter != Thing.DELETED_FOREVER) {
            mCounts[typeAfter][stateAfter]++;
            mCounts[typeBefore][3]--;
            mCounts[typeAfter][3]++;
        }
    }

    public void handleHabitRecorded(int newFinishedCount, int newRecordCount) {
        mHabitFinished += newFinishedCount;
        mHabitRecord += newRecordCount;
        mWriteFileRunnable.run();
    }

    public boolean isNormal() {
        for (int i = Thing.NOTE; i <= Thing.NOTIFY_EMPTY_DELETED; i++) {
            for (int j = Thing.UNDERWAY; j <= Thing.DELETED_FOREVER; j++) {
                if (mCounts[i][j] < 0 ||
                        mCounts[i][j] > mCounts[i][Thing.DELETED_FOREVER]) {
                    return false;
                }
            }
        }
        return true;
    }

    private void init() {
        int[][] counts = new int[21][4];

//        counts[Thing.NOTE][0] = 600;
//        counts[Thing.NOTE][3] = 600;

        for (int i = Thing.WELCOME_UNDERWAY; i <= Thing.WELCOME_GOAL; i++) {
            counts[i][0] = 1;
            counts[i][3] = 1;
        }
        counts[Thing.NOTIFY_EMPTY_FINISHED][0] = 1;
        counts[Thing.NOTIFY_EMPTY_FINISHED][3] = 1;
        counts[Thing.NOTIFY_EMPTY_DELETED][0] = 1;
        counts[Thing.NOTIFY_EMPTY_DELETED][3] = 1;
        mCounts = counts;
        mHabitFinished = 0;
        mHabitRecord = 0;
        writeToFile();
    }

    public void writeToFile() {
        try {
            FileOutputStream stream = mContext.openFileOutput(
                    Definitions.MetaData.THINGS_COUNTS_FILE_NAME, Context.MODE_PRIVATE);
            for (int i = 0; i < 21; i++) {
                for (int j = 0; j < 4; j++) {
                    stream.write(String.valueOf(mCounts[i][j]).getBytes());
                    stream.write(",".getBytes());
                }
            }
            stream.write(String.valueOf(mHabitFinished).getBytes());
            stream.write(",".getBytes());
            stream.write(String.valueOf(mHabitRecord).getBytes());
            stream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void readFromFile() {
        try {
            FileInputStream stream = mContext.openFileInput(
                    Definitions.MetaData.THINGS_COUNTS_FILE_NAME);
            int length = stream.available();
            byte[] bytes = new byte[stream.available()];
            int readLength = stream.read(bytes);
            if (length == readLength) {
                // Always go to this branch. No else.
                String str = new String(bytes);
                String[] countStr = str.split(",");
                mCounts = new int[21][4];
                for (int i = 0; i < 21; i++) {
                    for (int j = 0; j < 4; j++) {
                        mCounts[i][j] = Integer.valueOf(countStr[i * 4 + j]);
                    }
                }
                mHabitFinished = Integer.valueOf(countStr[84]);
                mHabitRecord = Integer.valueOf(countStr[85]);
            }
            stream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
